\contentsline {chapter}{\numberline {1}Introduction}{3}{}%
\contentsline {section}{\numberline {1.1}Project overview}{3}{}%
\contentsline {subsection}{\numberline {1.1.1}Code Structure}{3}{}%
\contentsline {subsection}{\numberline {1.1.2}MiniImp: An Imperative Language}{4}{}%
\contentsline {subsection}{\numberline {1.1.3}MiniFun: A Functional Language}{4}{}%
\contentsline {subsection}{\numberline {1.1.4}MiniTyFun: A Statically-Typed Functional Language}{5}{}%
\contentsline {section}{\numberline {1.2}Building and Running the Project}{5}{}%
\contentsline {subsection}{\numberline {1.2.1}Running the MiniImp Interpreter}{5}{}%
\contentsline {subsection}{\numberline {1.2.2}Running the MiniFun Interpreter}{6}{}%
\contentsline {chapter}{\numberline {2}MiniTyFun Type System}{7}{}%
\contentsline {section}{\numberline {2.1}Syntax Extensions}{7}{}%
\contentsline {chapter}{\numberline {3}Parser Design and Ambiguity Resolution}{8}{}%
\contentsline {section}{\numberline {3.1}MiniImp Parser: Ambiguities and Solutions}{8}{}%
\contentsline {subsection}{\numberline {3.1.1}The Dangling Semicolon Problem}{8}{}%
\contentsline {subsection}{\numberline {3.1.2}Operator Precedence}{8}{}%
\contentsline {subsection}{\numberline {3.1.3}Negative Number Ambiguity}{9}{}%
\contentsline {section}{\numberline {3.2}MiniFun Parser: Ambiguities and Solutions}{9}{}%
\contentsline {subsection}{\numberline {3.2.1}Let Body Precedence}{9}{}%
\contentsline {subsection}{\numberline {3.2.2}Function Application Precedence}{9}{}%
\contentsline {subsection}{\numberline {3.2.3}Application Associativity}{10}{}%
\contentsline {subsection}{\numberline {3.2.4}The Dangling Else (Same as MiniImp)}{10}{}%
\contentsline {chapter}{\numberline {4}Control Flow Graph Construction}{11}{}%
\contentsline {section}{\numberline {4.1}Minimal or maximal blocks}{11}{}%
\contentsline {section}{\numberline {4.2}Building Maximal Blocks Directly}{11}{}%
\contentsline {chapter}{\numberline {5}Translation from MiniImp to MiniRISC}{13}{}%
\contentsline {section}{\numberline {5.1}Variable Mapping Strategy}{13}{}%
\contentsline {section}{\numberline {5.2}Algebraic Simplification During Translation}{13}{}%
\contentsline {section}{\numberline {5.3}Translation of Control Flow}{14}{}%
\contentsline {subsection}{\numberline {5.3.1}Conditionals}{14}{}%
\contentsline {subsection}{\numberline {5.3.2}Loops}{14}{}%
\contentsline {chapter}{\numberline {6}Dataflow Analysis}{16}{}%
\contentsline {section}{\numberline {6.1}Definite Variables Analysis (Forward, Must)}{16}{}%
\contentsline {subsection}{\numberline {6.1.1}Algorithm Details}{16}{}%
\contentsline {subsection}{\numberline {6.1.2}Implementation}{16}{}%
\contentsline {section}{\numberline {6.2}Live Variables Analysis (Backward, May)}{18}{}%
\contentsline {subsection}{\numberline {6.2.1}Algorithm Details}{18}{}%
\contentsline {subsection}{\numberline {6.2.2}Data Structures}{19}{}%
\contentsline {subsection}{\numberline {6.2.3}Implementation}{19}{}%
\contentsline {subsection}{\numberline {6.2.4}Instruction-Level Liveness}{21}{}%
\contentsline {chapter}{\numberline {7}Optimization and Register Allocation}{23}{}%
\contentsline {section}{\numberline {7.1}Target Architecture}{23}{}%
\contentsline {section}{\numberline {7.2}Register Coalescing (Optional)}{23}{}%
\contentsline {subsection}{\numberline {7.2.1}Live Range Construction}{23}{}%
\contentsline {subsection}{\numberline {7.2.2}Interference Check}{24}{}%
\contentsline {subsection}{\numberline {7.2.3}Merging Algorithm}{24}{}%
\contentsline {section}{\numberline {7.3}Allocation \& Spilling}{25}{}%
\contentsline {subsection}{\numberline {7.3.1}Instruction Rewriting}{25}{}%
\contentsline {subsection}{\numberline {7.3.2}Allocation Decision}{26}{}%
